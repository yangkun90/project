## js深入研究

```javascript
var a =12;
//1.先声明一个变量 a 没有赋值默认赋值是undefined
//2.在当前作用域中开辟一个位置存储12这个值
//3.让变量a和12关联在一起（定义：赋值）
var b =a;
//交换的只是具体数值拷贝一份过去，而不是地址。
b =13;
console.log(a);

var ary1 = [12,23];
//对象数据本身比较复杂，解析器在堆内存中开拓一个空间用来存放对象数据中的键值对，然后再栈内存管理的是堆内存的地址。
var ary2 =ary1;
//这里赋值的其实堆内存地址
ary2.push(100);
console.log(ary1);

function sum(){
    var total=null;
    for(var i=0;i<arguments.length;i++){
        var item=argument[i];
        !isNaN(parseFloat(item)) ? total +=item:null;//这里排除了非数字的影响,parseInt parseFloat方法也行
    }
    return total;
}
//方法的名存储在内存栈中，方法体存放在堆内存中使用字符串的方式进行保存。
sum(12,32,34,'bb')
```

### 栈内存作用

1. 提供一个给代码自上而下的执行环境，代码都在栈内存中执行的
2. 由于基本数据类型比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存进去的。
3. 当栈内存销毁，那么基本数据类型值也被销毁。

### 堆内存作用

1. 存储引用类型值得，对象键值对，函数：字符串代码
2. 当前堆内存销毁释放，那么这个引用值彻底没有了
3. 如何让堆内存销毁？当堆内存没有被任何栈内存的变量占用。代码回收GC会在空闲的时候回收 （谷歌浏览器包括v8）
4. null空对象内存指针，变量重新赋值。销毁堆内存

### 变量提升

定义：当栈内存形成，js代码自上而下执行前，浏览器首先会把所有带有'var/function' 关键子的进行提前的声明或者定义。

这种预先处理机制称之为变量提升。

声明： var  function 一个变量表示声明

定义： a=12  定义其实就是赋值

带var 是只定义没有定义

带function 声明和赋值都完成了   `解释了为什么函数定义在后面可以在前面调用的原因`

变量提升只发生在当前作用域（例如：开始加载页面的时候只对全局作用域下的进行提升，因为此时函数中存储的都是字符串而已）

在全局作用域下声明的函数或者变量是全局变量，同理在私有作用域下声明的变量是私有变量

浏览器很懒，不会执行第二遍，也就是当代码遇到创建函数这部分代码后直接跳过即可，因为在提升阶段就已经完成函数的赋值操作了

私有作用域形成后不是立即马上执行，而是进行变量的提升（变量提升前，形参赋值）

在es6语法以前版本，只有函数具有私有作用域。

### 带var 和不带var

全局作用域下定义变量等于给window对象添加一个属性变量值就是属性值(私有作用域中声明的私有变量和window没有关系) 

`in`  判断变量是否是某个对象的一个属性

`'a' in window` 判断某个属性名是否是window对象的属性返回值是true和false

全局变量和win中的属性存在映射机制

如果不加var 本质可以看作是对window这个对象的属性操作`a=12  => window.a=12`

创建变量要加上var 因为概念不一样

`var a=b=12` 这样写b不带var

### 私有作用域下的带var和不带var

1. 带var 的私有作用域变量提升阶段，都声明为私有变量，和外界没有任何关系
2. 不带var 不是私有变量，会向它的上级作用域查找，看是否为上级的变量，不是继续向上一级查找，一直找到window 如果window也没有，就会在window中增加一个属性，这个时候等于在全局中增加了一个变量
3. 这种查找的机制叫做作用域链查找